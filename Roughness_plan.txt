High-Level Roughness Model Plan

Status: Step 4 complete. Step 5 (Core Intra-Facet Solver) skeleton implemented: incident mapping, shadowing, iterative scattering, one-bounce thermal self-heating, dome projection. Pending: canonical view-factor computation, conduction/temperature updates.

1. Configuration Updates
• apply_kernel_based_roughness: true
• roughness_kernel: 'spherical_cap'   # choose from ['spherical_cap', 'fractal', ...]
• kernel_subfacets_count: <N>         # number of sub-facets per kernel (e.g. 30)
• kernel_profile_angle_degrees: <φ>   # controls curvature for spherical_cap (0=flat, up to 90=hemisphere)
• kernel_directional_bins: <M>        # number of dome directional bins (e.g. facets of an icosphere)
• intra_facet_scatters: 2  # number of internal scattering iterations

2. Core Abstractions
• Define RoughnessKernel interface with methods:
    – canonical_subfacets() → (vertices[N], normals[N], areas[N])
    – canonical_F_ss() → np.ndarray shape (N×N)
    – canonical_F_sd(dome_bins=M) → np.ndarray shape (N×M)
• Implement SphericalCapKernel(profile_angle, subfacets_count)
• (Future) Implement FractalKernel, other patch shapes via same interface
• Define DirectionalityDome(dome_bins=M): holds fixed normals[M], areas[M]

3. Precompute Canonical View-Factors
• On first use of a given (kernel, N, M):
    a. Generate canonical sub-facet mesh (N triangles) and dome (M facets)
    b. Compute F_ss (N×N) among sub-facets
    c. Compute F_sd (N×M) from sub-facets into dome facets
    d. Cache arrays keyed by (kernel_type, N, φ, M)

4. Initialization of Roughness Model (ParentFacet.generate_roughness)
• If apply_kernel_based_roughness is false, skip
• Ask RoughnessKernel for canonical mesh; orient & scale into parent facet plane
• Instantiate SubFacet(parent_id, local_id=i, canonical_index=i) for i in 0…N−1
• Build DirectionalityDome(M); rotate dome normals to align dome pole with parent normal - use the same spherical_cap_mesh.py script to generate the dome (should have 90 degree profile angle)
• Store only local mapping to canonical indices (no per-instance storage of full mesh or VFs)

5. Core Intra-Facet Solver (Facet.process_intra_roughness_energetics)
Inputs: parent_incident_packets [(flux, dir_world, type_flag)], where type_flag∈{'solar','scattered_visible','thermal'}

Implemented Workflow:
  a. Preprocess incidents:
     - Map each world-space dir_vec → facet-local (via dome_rotation)
     - Shadow test each subfacet via calculate_shadowing against its canonical triangle
     - Compute incident energy = flux×area_i×cosθ
     - Accumulate into E0_vis (all visible incident) or E0_th (thermal incident), track absorbed fractions (1–albedo or 1–ε)

  b. Iterative scattering (visible):
     B_vis = Σ_{k=0..K−1} [ρ^k (F_ss^k · E0_vis)]
     (K = intra_facet_scatters)

  c. Thermal self-heating (no scattering):
     B_th_direct = ε · E0_th
     B_th_self   = F_ssᵀ · B_th_direct  # single-bounce
     B_th        = B_th_direct + B_th_self

  d. Project onto dome:
     out_vis[M] = F_sdᵀ · B_vis
     out_th[M]  = F_sdᵀ · B_th
     Store in depression_outgoing_flux_distribution

Deviations from original plan:
• Replaced analytic radiosity solves with iterative scattering loops (no matrix inversion needed).
• Thermal solved as direct emission + single-bounce, not full (I−(1−ε)F_ss)⁻¹.
• Integrated intra-facet shadowing for each incident ray using calculate_shadowing.
• Flat-disc shortcut and conduction/temperature update not yet implemented.
• _compute_canonical_view_factors() remains unimplemented.

6. Integration with Rest of Model
• Insolation & visible scattering:
    – Create solar packets on parents → process_intra_roughness_energetics
    – Use inter-parent view-factors on dome bins to distribute scattered energy
• Thermal self-heating:
    – Create thermal emission packets per dome bin → distribute to other parents
    – Recv on parent_incident_packets → process internally to update depression_total_absorbed_thermal_flux
• Phase curves:
    – After process_intra, sum dome bins pointed at observer for visible/thermal brightness

7. Development & Testing Strategy
• Flat-disc sanity: dome projection reproduces discrete Lambert cosine law
• Energy conservation: incident = absorbed + Σ(out_vis) + Σ(out_th)
• Mesh-convergence: vary N, M → track net-flux convergence
• Cross-validation: compare a handful of cases vs legacy MCRT code (<1% difference)
• Unit tests for:
    – RoughnessKernel canonical mesh/F_ss/F_sd shapes
    – Facet.generate_roughness idempotency and param change
    – process_intra logic for simple N=1 or N=2 toy kernels

8. Optional Next Steps
• Swap in new roughness kernels: fractal patches, Gaussian-bump kernels, user-supplied meshes
• Anisotropic / specular scattering: extend F_ss/F_sd integrals or add per-kernel BRDF functions
• Adaptive dome resolution: refine M in directions of high flux gradient
• GPU accelerate radiosity solves for very large N
• Hybrid MCRT fallback for extremely non-Lambertian kernels

9. Cleanup & Documentation
• Update README/docs: describe view-factor approach, config params, kernel interface
• Deprecate old MCRT internal code paths, remove config flags no longer needed

-- End of Plan --
